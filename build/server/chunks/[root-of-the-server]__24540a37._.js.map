{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///home/pantho/Desktop/cloudvault/app/api/files/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\n// Define the upload directory path\nconst uploadDir = path.join(process.cwd(), 'uploads');\n// Track file changes to support long polling\nlet lastFileChange = Date.now();\nlet clients: { resolve: (value: any) => void }[] = [];\n\n// Ensure the upload directory exists\nasync function ensureUploadDir() {\n  try {\n    await fs.access(uploadDir);\n  } catch {\n    await fs.mkdir(uploadDir, { recursive: true });\n  }\n}\n\n// Helper function to get file stats with name\nasync function getFileStats(fileName: string) {\n  const filePath = path.join(uploadDir, fileName);\n  const stats = await fs.stat(filePath);\n  return {\n    name: fileName,\n    size: stats.size,\n    modified: stats.mtime,\n    stats: stats\n  };\n}\n\n// Notify all waiting clients about changes\nfunction notifyClients() {\n  lastFileChange = Date.now();\n  const currentClients = [...clients];\n  clients = [];\n  currentClients.forEach(client => client.resolve(true));\n}\n\n// Long polling wait function\nasync function waitForChanges(since: number): Promise<boolean> {\n  if (since < lastFileChange) {\n    return true;\n  }\n  \n  return new Promise(resolve => {\n    const timeout = setTimeout(() => {\n      clients = clients.filter(c => c.resolve !== resolve);\n      resolve(false);\n    }, 30000); // 30 seconds timeout\n    \n    clients.push({\n      resolve: (value) => {\n        clearTimeout(timeout);\n        resolve(value);\n      }\n    });\n  });\n}\n\n// GET handler for file listing and file download\nexport async function GET(request: Request) {\n  await ensureUploadDir();\n  \n  const { searchParams } = new URL(request.url);\n  const fileName = searchParams.get('fileName');\n  const since = parseInt(searchParams.get('since') || '0', 10);\n  \n  // Handle long polling for file list changes\n  if (searchParams.has('poll') && !fileName) {\n    const hasChanges = await waitForChanges(since);\n    return NextResponse.json({ \n      changes: hasChanges, \n      timestamp: lastFileChange \n    });\n  }\n  \n  // If fileName is provided, handle file download\n  if (fileName) {\n    try {\n      const filePath = path.join(uploadDir, fileName);\n      \n      // Check if file exists\n      try {\n        await fs.access(filePath);\n      } catch {\n        return NextResponse.json(\n          { message: 'File not found' },\n          { status: 404 }\n        );\n      }\n      \n      // Read the file\n      const fileBuffer = await fs.readFile(filePath);\n      \n      // Determine content type (basic implementation)\n      let contentType = 'application/octet-stream';\n      const extension = path.extname(fileName).toLowerCase();\n      const contentTypeMap = {\n        '.txt': 'text/plain',\n        '.html': 'text/html',\n        '.css': 'text/css',\n        '.js': 'text/javascript',\n        '.json': 'application/json',\n        '.pdf': 'application/pdf',\n        '.png': 'image/png',\n        '.jpg': 'image/jpeg',\n        '.jpeg': 'image/jpeg',\n        '.gif': 'image/gif',\n        '.svg': 'image/svg+xml',\n      };\n      \n      if (contentTypeMap[extension as keyof typeof contentTypeMap]) {\n        contentType = contentTypeMap[extension as keyof typeof contentTypeMap];\n      }\n      \n      // Create response with appropriate headers\n      return new NextResponse(fileBuffer, {\n        headers: {\n          'Content-Type': contentType,\n          'Content-Disposition': `attachment; filename=\"${fileName}\"`,\n        },\n      });\n    } catch {\n      console.error('Download error:');\n      return NextResponse.json(\n        { message: 'Error downloading file' },\n        { status: 500 }\n      );\n    }\n  } \n  \n  // Otherwise, list all files\n  try {\n    const files = await fs.readdir(uploadDir);\n    const fileStats = await Promise.all(\n      files.map(async (fileName) => {\n        try {\n          return await getFileStats(fileName);\n        } catch {\n          console.error(`Error getting stats for ${fileName}:`);\n          return null;\n        }\n      })\n    );\n    \n    // Filter out any null values (files that had errors)\n    const validFiles = fileStats.filter(Boolean);\n    \n    return NextResponse.json({ \n      files: validFiles,\n      timestamp: lastFileChange\n    });\n  } catch {\n    console.error('Error listing files:');\n    return NextResponse.json(\n      { message: 'Error listing files' },\n      { status: 500 }\n    );\n  }\n}\n\n// POST handler for file upload\nexport async function POST(request: Request) {\n  await ensureUploadDir();\n  \n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File | null;\n    \n    if (!file) {\n      return NextResponse.json(\n        { message: 'No file provided' },\n        { status: 400 }\n      );\n    }\n    \n    // Get the file data\n    const buffer = Buffer.from(await file.arrayBuffer());\n    const filename = file.name.replace(/[^\\w\\s.-]/gi, ''); // Sanitize filename\n    const filepath = path.join(uploadDir, filename);\n    \n    // Write the file to the upload directory\n    await fs.writeFile(filepath, buffer);\n    \n    // Get file stats for the response\n    const fileStats = await getFileStats(filename);\n    \n    // Notify clients about the change\n    notifyClients();\n    \n    return NextResponse.json({\n      message: 'File uploaded successfully',\n      file: fileStats,\n      timestamp: lastFileChange\n    });\n  } catch (error) {\n    console.error('Upload error:', error);\n    return NextResponse.json(\n      { message: 'Error uploading file' },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE handler for file deletion\nexport async function DELETE(request: Request) {\n  await ensureUploadDir();\n  \n  const { searchParams } = new URL(request.url);\n  const fileName = searchParams.get('fileName');\n  \n  if (!fileName) {\n    return NextResponse.json(\n      { message: 'No filename provided' },\n      { status: 400 }\n    );\n  }\n  \n  try {\n    const filePath = path.join(uploadDir, fileName);\n    \n    // Check if file exists\n    try {\n      await fs.access(filePath);\n    } catch {\n      return NextResponse.json(\n        { message: 'File not found' },\n        { status: 404 }\n      );\n    }\n    \n    // Delete the file\n    await fs.unlink(filePath);\n    \n    // Notify clients about the change\n    notifyClients();\n    \n    return NextResponse.json({\n      message: 'File deleted successfully',\n      timestamp: lastFileChange\n    });\n  } catch (error) {\n    console.error('Delete error:', error);\n    return NextResponse.json(\n      { message: 'Error deleting file' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}